## 微服务是什么？
微服务（Microservices）是一种**软件架构风格**，其核心思想是将一个大型的单体应用（Monolithic Application）拆分为一组**小型、独立、松耦合**的服务。每个服务专注于完成**单一业务功能**，并通过轻量级的通信机制（如 HTTP/REST、消息队列等）协同工作，共同实现完整的系统功能。

---

### 与单体架构对比
| **维度**         | **单体架构**               | **微服务架构**               |
|------------------|--------------------------|---------------------------|
| **开发速度**      | 初期快，后期慢           | 初期复杂，长期迭代快       |
| **部署**          | 整体部署，风险高         | 独立部署，风险分散         |
| **技术栈**        | 单一技术                 | 混合技术（按需选择）       |
| **扩展性**        | 垂直扩展（提升单机性能） | 水平扩展（增加服务实例）   |
| **故障影响**      | 全局瘫痪                 | 局部故障，可降级处理       |

---

### 总结
微服务不是“银弹”，适合中大型复杂系统，但对团队技术能力和运维要求较高。采用前需权衡业务需求、团队规模和基础设施条件。
>“银弹”是一个比喻，指能快速、彻底解决复杂问题的神奇方法，源自西方民间传说——传说中只有用银质子弹才能杀死狼人、吸血鬼等超自然生物。在技术或工程领域，“银弹”常被用来形容那些被认为可以“一劳永逸”解决所有难题的技术、工具或方法。


## 服务单元、发布单元、微服务有什么区别
- 服务单元：是**业务逻辑**上的功能模块划分，代表系统中一个高内聚、低耦合的业务能力。它强调职责的独立性，但不一定对应独立的部署实体。
- 发布单元：是**运维层面**可独立部署的最小实体，指一次部署操作中更新的代码或资源集合。它是运维层面的概念，关注部署的原子性。
- 微服务：是**同时满足服务单元和发布单元标准的架构实现**，即：业务上：独立的功能模块（服务单元）。技术上：独立进程、可单独部署（发布单元）。

---

### 三者的关系对比
| **维度**       | **服务单元**               | **发布单元**               | **微服务**                 |
|----------------|--------------------------|--------------------------|--------------------------|
| **核心关注点** | 业务逻辑划分              | 部署和交付               | 业务+部署的完整独立性     |
| **物理形态**   | 代码/模块/组件            | 可执行包/容器/镜像       | 独立进程（容器/虚拟机）   |
| **通信方式**   | 本地调用或远程通信        | 无直接关系               | 必须远程通信（HTTP等）    |
| **典型示例**   | 单体中的`OrderService`类 | 单体应用的WAR包          | 独立的“订单服务”容器      |

---

### 常见误区澄清
1. **“微服务一定是发布单元，但发布单元不一定是微服务”**
    - ✅ 正确：微服务必须独立部署（发布单元），但发布单元可能是一个单体应用的整体部署。

2. **“服务单元可以跨微服务存在”**
    - ❌ 错误：微服务内部可以包含多个服务单元（模块），但一个服务单元不能跨微服务，否则违背微服务的自治性原则。

3. **“所有服务单元都需要拆成微服务”**
    - ❌ 错误：只有需要独立扩展、迭代或技术异构的服务单元才适合拆为微服务，否则会导致过度拆分（Nanoserivce反模式）。

---

### 总结
- **服务单元** = **“做什么”**（业务逻辑划分）
- **发布单元** = **“怎么交付”**（部署原子性）
- **微服务** = **“独立的全栈业务单元”**（业务+部署的双重独立）

理解这三者的区别，能帮助你在架构设计中更精准地定义服务边界，避免“为微服务而微服务”的陷阱。

## 三层架构 vs 四层架构核心区别

### 1. 领域层纯度
   - 三层：领域层混合业务逻辑与技术细节（如JPA注解、直接调用Redis），技术耦合度高。
   - 四层：领域层完全纯净，仅含业务逻辑，技术实现通过接口抽象至基础设施层。

### 2. 技术解耦方式
   - 三层：隐式耦合（领域层依赖Repository接口或技术工具）。
   - 四层：显式解耦（依赖倒置），领域层仅依赖抽象接口。

### 3. 适用场景
   - **三层**：业务简单、技术栈稳定的中小项目（如后台管理系统），追求开发效率。
   - **四层**：业务复杂、需长期演进或技术可能变更的系统（如金融核心、电商平台），强调可维护性。

### 总结
**本质差异**：四层通过严格分层实现领域模型与技术实现的完全隔离，代价是更高的设计成本；三层以技术耦合换取开发速度。选型取决于业务复杂度与技术灵活性需求。

# Oracle数据库碎片化处理指南
Oracle数据库碎片化主要分为表碎片、索引碎片和表空间碎片三种类型。以下是针对Oracle数据库的碎片化处理方法：

## 一、碎片检测方法

### 1. 表碎片检测
```sql
-- 检查表的高水位线(HWM)和实际使用情况
SELECT table_name, 
       ROUND((blocks * 8), 2) "高水位线(KB)",
       ROUND((num_rows * avg_row_len / 1024), 2) "实际使用(KB)",
       ROUND((blocks * 8), 2) - ROUND((num_rows * avg_row_len / 1024), 2) "浪费空间(KB)"
FROM user_tables 
WHERE table_name = '表名';
```

### 2. 索引碎片检测
```sql
-- 检查索引碎片情况
SELECT index_name, 
       ROUND(100 * del_lf_rows / lf_rows, 2) "碎片率(%)" 
FROM index_stats 
WHERE lf_rows > 0;
```

### 3. 表空间碎片检测
```sql
-- 检查表空间碎片情况
SELECT tablespace_name, 
       COUNT(*) "碎片数量",
       MAX(block_id) - MIN(block_id) + 1 "总块数",
       SUM(bytes)/1024/1024 "总大小(MB)",
       (MAX(block_id) - MIN(block_id) + 1 - COUNT(*)) / (MAX(block_id) - MIN(block_id) + 1) * 100 "碎片率(%)"
FROM dba_free_space
GROUP BY tablespace_name
ORDER BY 5 DESC;
```

## 二、碎片处理方法

### 1. 表碎片处理
```sql
-- 方法1：移动表重建(会重建所有索引)
ALTER TABLE 表名 MOVE TABLESPACE 表空间名;

-- 方法2：在线重定义(不影响业务)
BEGIN
  DBMS_REDEFINITION.start_redef_table(
    uname => '用户名',
    orig_table => '原表名',
    int_table => '中间表名');
  DBMS_REDEFINITION.finish_redef_table(
    uname => '用户名',
    orig_table => '原表名',
    int_table => '中间表名');
END;
/

-- 方法3：收缩表(需要开启行移动)
ALTER TABLE 表名 ENABLE ROW MOVEMENT;
ALTER TABLE 表名 SHRINK SPACE CASCADE;
```

### 2. 索引碎片处理
```sql
-- 方法1：重建索引
ALTER INDEX 索引名 REBUILD TABLESPACE 表空间名;

-- 方法2：联机重建索引(10g及以上)
ALTER INDEX 索引名 REBUILD ONLINE;

-- 方法3：合并索引碎片
ALTER INDEX 索引名 COALESCE;
```

### 3. 表空间碎片处理
```sql
-- 方法1：重组表空间(需要停机)
-- 导出所有对象，删除表空间，重建表空间，导入数据

-- 方法2：使用可传输表空间
-- 适用于大表空间的重组
```

## 三、自动维护策略

### 1. 定期收集统计信息
```sql
-- 自动收集统计信息(默认已开启)
-- 手动收集：
EXEC DBMS_STATS.GATHER_SCHEMA_STATS('用户名', estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE);
```

### 2. 设置自动段空间管理
```sql
-- 创建表空间时指定自动段空间管理
CREATE TABLESPACE 表空间名 
DATAFILE '数据文件路径' SIZE 大小
EXTENT MANAGEMENT LOCAL 
SEGMENT SPACE MANAGEMENT AUTO;
```

### 3. 定期执行碎片整理脚本
```sql
-- 自动检测并重建高碎片率对象
-- 可结合DBMS_SCHEDULER创建定期任务
```

## 四、注意事项

1. **操作时间窗口**：MOVE和REBUILD操作会锁表，建议在维护窗口进行
2. **空间需求**：重建操作需要额外空间，确保有足够空间
3. **权限要求**：需要相应系统权限
4. **依赖对象**：重建表会导致所有依赖对象失效，需要重新编译
5. **RAC环境**：在RAC环境中需特别注意锁定机制

## 五、预防措施

1. 合理设置PCTFREE和PCTUSED参数
2. 使用本地管理的表空间(LMT)
3. 启用自动段空间管理(ASSM)
4. 定期维护和监控
5. 对大表考虑使用分区表

通过以上方法可以有效管理和减少Oracle数据库中的碎片，保持数据库性能稳定。


# 多线程拒绝策略

在多线程编程中，当线程池或任务队列达到其容量限制时，需要采用拒绝策略来处理新提交的任务。以下是常见的几种拒绝策略：

## 1. AbortPolicy（中止策略）
- **默认策略**
- 直接抛出 `RejectedExecutionException` 异常
- 调用者可以捕获这个异常并处理

## 2. CallerRunsPolicy（调用者运行策略）
- 让提交任务的线程自己执行该任务
- 这种策略会降低新任务的提交速度，起到简单的反馈控制作用

## 3. DiscardPolicy（丢弃策略）
- 直接静默丢弃无法处理的任务
- 不抛出任何异常，也不执行任何操作

## 4. DiscardOldestPolicy（丢弃最老策略）
- 丢弃队列中最老的任务（即最早进入队列的任务）
- 然后尝试重新提交当前任务

## 5. 自定义拒绝策略
- 实现 `RejectedExecutionHandler` 接口
- 根据业务需求自定义拒绝逻辑

## 使用示例（Java线程池）

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize,
    maximumPoolSize,
    keepAliveTime,
    TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<Runnable>(capacity),
    new ThreadPoolExecutor.AbortPolicy() // 设置拒绝策略
);
```

选择哪种拒绝策略取决于具体的应用场景和对任务丢失的容忍程度。