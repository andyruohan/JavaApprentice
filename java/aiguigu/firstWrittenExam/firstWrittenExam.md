## mysql 最左前缀法则示例
假设index(a,b,c)  

| Where语句                                                | 索引是否被使用                                                                                     |
|--------------------------------------------------------|---------------------------------------------------------------------------------------------|
| where a = 3                                            | 是，使用到 a                                                                                     |
| where a =  3 and b = 5                                 | 是，使用到 a、b                                                                                   |
| where a =  3 and b = 5 and c = 4                       | 是，使用到 a、b、c                                                                                 |
| where b =  3 或者 where b = 3 and c =  4 或者 where c =  4 | 否                                                                                           |
| where a =  3 and c = 5                                 | 使用到 a，但是 c 不可以，b 中间断了                                                                       |
| where a =  3 and b > 4 and c = 5                       | 使用到 a 和 b，c 不能用在范围之后，b断了                                                                    |
| where a is  null and b is not null                     | is null 支持索引，但是 is not null 不支持，所以 a 可以使用索引，但是 b 不一定能用上索引（该描述基于mysql 8.0，也可能不成立取决于具体数据库的版本） |
| where a  <> 3                                          | 不能使用索引                                                                                      |
| where  abs(a) =3                                       | 不能使用索引                                                                                      |
| where a =  3 and b like 'kk%' and c = 4                | 是，使用到 a、b、c                                                                                 |
| where a =  3 and b like '%kk' and c = 4                | 是，只用到 a                                                                                     |
| where a =  3 and b like '%kk%' and c = 4               | 是，只用到 a                                                                                     |
| where a =  3 and b like 'k%kk%' and c =  4             | 是，使用到 a、b、c                                                                                 |

可以结合字典排序来理解:
1) 如`where a =  3 and c = 5`，就类似于查找单词找`a%c`，由于中间这一段不知道是啥，因此只能根据索引找到`a`，剩余的只能通过全表扫描。
2) 如`where a =  3 and b > 4 and c = 5`，就类似查找单词，先根据索引找到字母为`a`的，然后根据索引找到字母大于`b`，但在大于`b`后再找字母为`c`的就很难找了，需要对`ac、ae、...、az`打头的单词逐个核对。
3) 如`where a  <> 3`，就类似于查找单词，除`a`打头的单词全部查找一遍。

### 如何分析 explain 语句
如下面的 explain 语句：
```
mysql> EXPLAIN SELECT * FROM emp where age = 33 and deptId = '2027' and name = 'rPZBJR';
+----+-------------+-------+------------+------+---------------------+---------------------+---------+-------------------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys       | key                 | key_len | ref               | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------------+---------------------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | emp   | NULL       | ref  | idx_age_deptid_name | idx_age_deptid_name | 93      | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------------+---------------------+---------+-------------------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)
```
每列代表的意义为：
- **id**: 查询中的每个操作步骤都有一个唯一的标识符，这里只有一个操作步骤，所以标识符为 1。
- **select_type**: SIMPLE 表示这是一个简单的 SELECT 查询，没有 UNION 或子查询等复杂的结构。
- **table**: 表示查询涉及的表名，这里是 emp 表。
- **partitions**: 如果查询涉及分区表，此列将显示相关分区信息。
- **type**: 这是非常重要的一列，表示了在表中找到行的方式。在这里，类型是 ref，表示查询使用了索引的“引用”（ref）访问方法。
- **possible_keys**: 这列显示了可能被查询使用的索引，这里可能使用的索引是 idx_age_deptid_name。
- **key**: 表示实际使用的索引，这里使用了索引 idx_age_deptid_name。
- **key_len**: 表示索引的长度，这里是 93 个字节。
- **ref**: 显示了在索引中使用的列和值，这里是 const,const,const，表示在索引中使用了常量值。
- **rows**: 表示 MySQL 估计查询需要检查的行数，这里是 1 行。
- **filtered**: 表示通过索引条件过滤的行的百分比，这里是 100.00%，表示索引条件过滤了 100% 的行。
- Extra: 提供了其他信息，这里为 NULL，表示没有额外的操作。
**综上所述**，查询使用了索引 idx_age_deptid_name，并且使用了索引的引用（ref）访问方法来检索数据，通过索引条件过滤了所有行，并且没有进行额外的排序操作。

其中，需要重点关注的列：
- **type**: 这列显示了在表中找到行的方式。常见的类型包括：
  - **ALL**: 表示全表扫描，即检索表中的所有行。
  - **index**: 表示全索引扫描，即扫描整个索引而不访问实际的数据行。
  - **range**: 表示使用索引进行范围扫描，即根据索引列上的范围条件来检索数据。
  - **ref**: 表示使用索引引用（ref）访问方法，通常与等值查询条件一起使用。
  - **const**: 表示使用索引常量（const）访问方法，通常与等值查询条件一起使用。
  - **eq_ref**: 表示连接查询中使用了索引唯一性的情况。
- **possible_keys**: 这列显示了可能被查询使用的索引。如果存在多个索引，这些索引中的一个或多个可能会被用于查询。
- **key**: 这列显示了实际被查询使用的索引。通常，你希望看到查询使用了一个合适的索引。
- **rows**: 这列表示 MySQL 估计查询需要检查的行数。较小的值表示较高的性能，因为查询需要检查的行越少，查询的执行速度越快。
- **filtered**: 这列表示通过索引条件过滤的行的百分比。通常情况下，你希望这个值越高越好，因为这表示索引条件过滤了更多的行，减少了查询的处理量。
- **Extra**: 这列提供了关于查询执行过程的额外信息。一些常见的值包括 "Using index"（表示查询使用了覆盖索引）、"Using where"（表示查询使用了 WHERE 子句中的条件）、"Using temporary"（表示查询需要使用临时表）、"Using filesort"（表示查询需要对结果进行排序）等。


### 案例实测
#### 无过滤不索引
1) 查看索引
```
mysql> SHOW INDEX FROM emp;
+-------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name            | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| emp   |          0 | PRIMARY             |            1 | id          | A         |      499086 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| emp   |          1 | idx_age_deptid_name |            1 | age         | A         |          20 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| emp   |          1 | idx_age_deptid_name |            2 | deptId      | A         |      188125 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| emp   |          1 | idx_age_deptid_name |            3 | name        | A         |      499086 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+-------+------------+---------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
4 rows in set (0.07 sec)
```
可以看到名为 idx_age_deptid_name 的组合索引：age + deptId + name。

2) 无过滤条件`(即无where)`执行 sql
```
mysql> EXPLAIN SELECT * FROM emp ORDER BY age,deptid;
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | emp   | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 499086 |   100.00 | Using filesort |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set, 1 warning (0.01 sec)
```
Extra 栏使用了 `filesort`。

3) 有过滤条件`(即有where)`执行 sql
```
mysql> EXPLAIN SELECT * FROM emp where age > 1000 ORDER BY age,deptid;
+----+-------------+-------+------------+-------+---------------------+---------------------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------------+---------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | emp   | NULL       | range | idx_age_deptid_name | idx_age_deptid_name | 5       | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------------+---------------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.01 sec)
```
Extra 栏使用了 `index condition`。


## JVM 内存模型中，为什么要区分新生代和年老代，对于新生代为什么又要区分 eden 区、survivor 区?
### 为什么要区分新生代和年老代核心要点
- 不同年龄代收集算法不同
- 对内存连续空间的处理不同（亦即垃圾碎片的处理）

### 新生代为什么又要区分 eden 区、survivor 区核心要点
- 为了更有效的区分哪些对象应该被复制到老年代

### 知识延伸
#### 新生代的流转过程
![image-20230312072639148](img/image-20230312072639148.png)
1) 新对象会被保存到 eden 区（开始是空的所以内存连续），eden 区满了会把有效对象复制到 s0（s0 也是空的所以也是连续空间） 
2) 清空 eden 区（再次写入时又是连续空间） 
3) s0 和 s1 在命名上互换，原来的 s1 等待写入（空的） 
4) eden区再次满了，重复上面步骤

#### 不同年代的代表算法
1) 新生代：复制算法，如半空间复制算法。
2) 老年代：标记-整理-清除算法，如 CMS（没有整理环节，有可能产生垃圾碎片）、G1 算法。